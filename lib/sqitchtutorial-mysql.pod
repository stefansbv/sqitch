=encoding UTF-8

=head1 Name

sqitchtutorial-mysql - A tutorial introduction to Sqitch change management on MySQL

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled MySQL project, use a VCS
for deployment planning, and work with other developers to make sure changes
remain in sync and in the proper order.

We'll start by creating new project from scratch, a fictional antisocial
networking site called Flipr. All examples use L<Git|http://git-scm.com/> as
the VCS and L<MySQL|http://dev.mysql.com/> as the storage engine.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr 
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Initialize project, add README.'
  [master (root-commit) 9c991b9] Initialize project, add README.
   1 file changed, 38 insertions(+)
   create mode 100644 README.md

If you're a Git user and want to follow along the history, the repository used
in these examples is L<on GitHub|https://github.com/theory/sqitch-mysql-intro>.

Now that we have a repository, let's get started with Sqitch. Every Sqitch
project must have a name associated with it, and, optionally, a unique URI. We
recommend including the URI, as it increases the uniqueness of object
identifiers internally, so let's specify one when we initialize Sqitch:

  > sqitch --engine mysql init flipr --uri https://github.com/theory/sqitch-mysql-intro/
  Created sqitch.conf
  Created sqitch.plan
  Created deploy/
  Created revert/
  Created verify/

Let's have a look at F<sqitch.conf>:

  > cat sqitch.conf 
  [core]
  	engine = mysql
  	# plan_file = sqitch.plan
  	# top_dir = .
  	# deploy_dir = deploy
  	# revert_dir = revert
  	# verify_dir = verify
  	# extension = sql
  # [core "mysql"]
  	# client = mysql
  	# username = 
  	# password = 
  	# db_name = 
  	# host = 
  	# port = 
  	# sqitch_db = sqitch

Good, it picked up on the fact that we're creating changes for the MySQL
engine, thanks to the C<--engine mysql> option, and saved it to the file.
Furthermore, it wrote a commented-out C<[core "mysql"]> section with all the
available MySQL engine-specific settings commented out and ready to be edited
as appropriate.

By default, Sqitch will read F<sqitch.conf> in the current directory for
settings. But it will also read F<~/.sqitch/sqitch.conf> for user-specific
settings. Since MySQL's
L<C<mysql> client|https://dev.mysql.com/doc/refman/5.6/en/mysql.html> is not
in the path on my system, let's go ahead an tell it where to find the client
on our computer:

  > sqitch config --user core.mysql.client /opt/local/mysql/bin/psql

And let's also tell it who we are, since this data will be used in all
of our projects:

  > sqitch config --user user.name 'Marge N. O’Vera'
  > sqitch config --user user.email 'marge@example.com'

Have a look at F<~/.sqitch/sqitch.conf> and you'll see this:

  > cat ~/.sqitch/sqitch.conf
  [core "mysql"]
  	client = /opt/local/mysql/bin/psql
  [user]
  	name = Marge N. O’Vera
  	email = marge@example.com

Which means that Sqitch should be able to find C<mysql> for any project, and
that it will always properly identify us when planning and committing changes.

Back to the repository. Have a look at the plan file, F<sqitch.plan>:

  > cat sqitch.plan
  %syntax-version=1.0.0-b2
  %project=flipr
  %uri=https://github.com/theory/sqitch-mysql-intro/
  

Note that it has picked up on the name and URI of the app we're building.
Sqitch uses this data to manage cross-project dependencies. The
C<%syntax-version> pragma is always set by Sqitch, so that it always knows how
to parse the plan, even if the format changes in the future.

Let's commit these changes and start creating the database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'
  [master 0738c94] Initialize Sqitch configuration.
   2 files changed, 23 insertions(+)
   create mode 100644 sqitch.conf
   create mode 100644 sqitch.plan

=head1 Our First Change

First, our app will need a database user, so let's create one. Run this
command:

  > sqitch add appuser -n 'Creates a an application user.'
  Created deploy/appuser.sql
  Created revert/appuser.sql
  Created verify/appuser.sql
  Added "appuser" to sqitch.plan

The L<C<add>|sqitch-add> command adds a database change to the plan and writes
deploy, revert, and verify scripts that represent the change. Now we edit
these files. The C<deploy> script's job is to create the table. By default,
the F<deploy/appuser.sql> file looks like this:

  -- Deploy appuser

  BEGIN;

  -- XXX Add DDLs here.

  COMMIT;

What we want to do is to replace the C<XXX> comment with the C<CREATE USER>
statement, like so:

  -- Deploy users

  BEGIN;

  CREATE USER flipr;

  COMMIT;

The C<revert> script's job is to precisely revert the change to the deploy
script, so we edit this to F<revert/appuser.sql> to look like this:

  -- Revert users

  BEGIN;

  DROP USER flipr;

  COMMIT;

Now we can try deploying this change:

  > mysql -u root --execute 'CREATE DATABASE flipr_test'
  > sqitch --db-name flipr_test --db-user root deploy
  Adding metadata tables to flipr_test
  Deploying to flipr_test
    + appuser .. ok

First Sqitch created the metadata database and tables used to track database
changes. This database is separate from the database to which the C<appuser>
change was deployed; by default, it is named C<sqitch>, but if you'd like it
to have a different name, set the C<core.mysql.sqitch_db> configuration
variable:

  > sqitch config core.mysql.sqitch_db $name

Ideally, only Sqitch data will be stored in this database, so it probably makes
the most sense to create a superuser named C<sqitch> or something similar and
use it to deploy changes.

Next, Sqitch deploys changes to the destination database, which we specified
on the command-line. We only have one so far; the C<+> reinforces the idea
that the change is being I<added> to the database.

With this change deployed, if you connect to the database, you'll be able to
see the user:

  > mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
  +-------+
  | User  |
  +-------+
  | flipr |
  +-------+

=head2 Trust, But Verify

But that's too much work. do you really want to do something like that after
every deploy?

Here's where the C<verify> script comes in. Its job is to test that the deploy
did was it was supposed to. It should do so without regard to any data that
might be in the database, and should throw an error if the deploy was not
successful. The simplest way to throw an error if a user does not exist is to
check the C<mysql.user> table. However, throwing an error in the event that
the user does not exist is trickier in MySQL. To simplify things, Sqitch
provides a custom function you can use in your tests, C<checkit()>. It works
kind of like a C<CHECK> constraint in other databases: pass an expression
as the first argument, and an error message as the second. If the expression
evaluates to false, an exception will be thrown with the error message.

Give it a try. Put this query into F<verify/appuser.sql>:

  SELECT sqitch.checkit(COUNT(*), 'User "flipr" does not exist')
    FROM mysql.user WHERE user = 'flipr';

This will work well as long as we know that the Sqitch database is named
C<sqitch>. If you've set C<core.mysql.sqitch_db> to a different value, you
will need to make sure you specify the correct datbase name in the script.

Now you can run the C<verify> script with the L<C<verify>|sqitch-verify>
command:

  > sqitch --db-name flipr_test --db-user root verify
  Verifying flipr_test
    * appuser .. ok
  Verify successful

Looks good! If you want to make sure that the verify script correctly dies if
the table doesn't exist, temporarily change the user name in the script to
something that doesn't exist, something like:

  SELECT sqitch.checkit(COUNT(*), 'User "flipr" does not exist')
    FROM mysql.user WHERE user = 'nonesuch';

Then L<C<verify>|sqitch-verify> again:

  > sqitch --db-name flipr_test --db-user root verify
  Verifying flipr_test
    * appuser .. ERROR 1644 (ERR0R) at line 5 in file: 'verify/appuser.sql': User "flipr" does not exist
  # Verify script "verify/appuser.sql" failed.
  not ok

  Verify Summary Report
  ---------------------
  Changes: 1
  Errors:  1
  Verify failed

The C<checkit()> function is kind enough to use the error message to tell us
what the problem is. Don't forget to change the table name back before
continuing!

=head2 Status, Revert, Log, Repeat

For purely informational purposes, we can always see how a deployment was
recorded via the L<C<status>|sqitch-status> command, which reads the tables
from the metadata database:

  > sqitch --db-name flipr_test --db-user root status
  # On database flipr_test
  # Project:  flipr
  # Change:   df801cddbb329ee14e6641670a214804f4384129
  # Name:     appuser
  # Deployed: 2013-07-01 18:42:51 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

Let's make sure that we can revert the change:

  > sqitch --db-name flipr_test --db-user root revert
  Revert all changes from flipr_test? [Yes]
    - appuser .. ok

The L<C<revert>|sqitch-revert> command first prompts to make sure that we
really do want to revert. This is to prevent unnecessary accidents. You can
pass the C<-y> option to disable the prompt. Also, notice the C<-> before the
change name in the output, which reinforces that the change is being
I<removed> from the database. And now the schema should be gone:

  > mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"

And the status message should reflect as much:

  > sqitch --db-name flipr_test --db-user root status
  # On database flipr_test
  No changes deployed

Of course, since nothing is deployed, the L<C<verify>|sqitch-verify> command
has nothing to verify:

  > sqitch --db-name flipr_test --db-user root verify
  Verifying flipr_test
  No changes deployed

However, we still have a record that the change happened, visible via the
L<C<log>|sqitch-log> command:

  > sqitch --db-name flipr_test --db-user root log
  On database flipr_test
  Revert df801cddbb329ee14e6641670a214804f4384129
  Name:      appuser
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2013-07-01 20:55:51 +0200

      Creates a an application user.

  Deploy df801cddbb329ee14e6641670a214804f4384129
  Name:      appuser
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2013-07-01 18:42:51 +0200

      Creates a an application user.

Note that the actions we took are shown in reverse chronological order, with
the revert first and then the deploy.

Cool. Now let's commit it.

  > git add .
  > git commit -m 'Add the "flipr" user.'
  [new 700df87] Add the "flipr" user.
   4 files changed, 23 insertions(+)
   create mode 100644 deploy/appuser.sql
   create mode 100644 revert/appuser.sql
   create mode 100644 verify/appuser.sql

And then deploy again. This time, let's use the C<--verify> option, so that
the C<verify> script is applied when the change is deployed:

  > sqitch --db-name flipr_test --db-user root deploy
  Deploying changes to flipr_test
	+ appuser .. ok

And now the C<flipr> user should be back:

  > mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
  +-------+
  | user  |
  +-------+
  | flipr |
  +-------+

When we look at the status, the deployment will be there:

  > sqitch --db-name flipr_test --db-user root status
  # On database flipr_test
  # Project:  flipr
  # Change:   df801cddbb329ee14e6641670a214804f4384129
  # Name:     appuser
  # Deployed: 2013-07-01 20:57:54 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

=head1 More Configuration

I'm getting a little tired of always having to type
C<--db-user root --db-name flipr_test>, aren't you? Let's just make that the
default, shall we?

  > sqitch config core.mysql.username root
  > sqitch config core.mysql.db_name flipr_test

Now we can leave it out, unless we need to deploy to another database. Which
we will, eventually, but at least our examples will be simpler from here on
in, e.g.:

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   df801cddbb329ee14e6641670a214804f4384129
  # Name:     appuser
  # Deployed: 2013-07-01 20:57:54 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

Yay, that allows things to be a little more concise. Let's also make sure that
changes are verified after deploying them:

  > sqitch config --bool deploy.verify true
  > sqitch config --bool rebase.verify true

We'll see the L<C<rebase>|sqitch-rebase> command a bit later. In the meantime,
let's commit the new configuration and and make some more changes!

  > git commit -am 'Set default DB name and always verify.'
  [master bb35c99] Set default DB name and always verify.
   1 file changed, 7 insertions(+)

=head1 Deploy with Dependency

Let's add another change, this time to create a table. Our app will need
users, of course, so we'll create a table for them. First, add the new change:

  > sqitch add users --requires appuser -n 'Creates table to track our users.'
  Created deploy/users.sql
  Created revert/users.sql
  Created verify/users.sql
  Added "users [appuser]" to sqitch.plan

Note that we're requiring the C<appuser> change as a dependency of the new
C<users> change. Although that change has already been added to the plan and
therefore should always be applied before the C<users> change, it's a good
idea to be explicit about dependencies.

Now edit the scripts. When you're done, F<deploy/users.sql> should look like
this:

  -- Deploy users
  -- requires: appuser

  BEGIN;

  CREATE TABLE users (
      nickname  VARCHAR(512) PRIMARY KEY,
      password  VARCHAR(512) NOT NULL,
      timestamp DATETIME(6)  NOT NULL
  );

  GRANT SELECT ON TABLE users TO flipr;

  COMMIT;

A few things to notice here. On the second line, the dependence on the
C<appuser> change has been listed. This doesn't do anything, but the default
C<deploy> template lists it here for your reference while editing the file.
Useful, right?

The C<flipr> user has been granged C<SELECT> access to the table. The app's
got to be able to read the data, right? This is why we need to require the
C<appuser> change.

Now for the verify script. The simplest way to check that the table was
created and has the expected columns without touching the data? Just select
from the table with a false C<WHERE> clause. Add this to F<verify/users.sql>:

  SELECT nickname, password, timestamp
    FROM flipr.users
   WHERE FALSE;

Now for the revert script: all we have to do is drop the table. Add this to
F<revert/users.sql>:

  DROP TABLE users;

Couldn't be much simpler, right? Let's deploy this bad boy:

  > sqitch deploy
  Deploying changes to flipr_test
    + users .. ok

We know, since verification is enabled, that the table must have been created.
But for the purposes of visibility, let's have a quick look:

  > mysql -u root -D flipr_test --execute 'SHOW TABLES'
  +----------------------+
  | Tables_in_flipr_test |
  +----------------------+
  | users                |
  +----------------------+

We can also verify all currently deployed changes with the
L<C<verify>|sqitch-verify> command:

  > sqitch verify
  Verifying flipr_test
    * appuser .. ok
    * users .... ok
  Verify successful

Now have a look at the status:

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   53c520dea482be30c426f241e74f5cbc58f3febc
  # Name:     users
  # Deployed: 2013-07-01 21:41:37 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

  > sqitch revert --to @HEAD^ -y
  Reverting changes to appuser from flipr_test
    - users .. ok

Note that we've used the C<--to> option to specify the change to revert to.
And what do we revert to? The symbolic tag C<@HEAD>, when passed to
L<C<revert>|sqitch-revert>, always refers to the last change deployed to the
database. (For other commands, it refers to the last change in the plan.)
Appending the caret (C<^>) tells Sqitch to select the change I<prior> to the
last deployed change. So we revert to C<appuser>, the penultimate change. The
other potentially useful symbolic tag is C<@ROOT>, which refers to the first
change deployed to the database (or in the plan, depending on the command).

Back to the database. The C<users> table should be gone but the C<flipr> user
should still be around:

  > mysql -u root -D flipr_test --execute 'SHOW TABLES'
  > mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
  +-------+
  | User  |
  +-------+
  | flipr |
  +-------+

The L<C<status>|sqitch-status> command politely informs us that we have
undeployed changes:

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   df801cddbb329ee14e6641670a214804f4384129
  # Name:     appuser
  # Deployed: 2013-07-01 20:57:54 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Undeployed change:
    * users

As does the L<C<verify>|sqitch-verify> command:

  > sqitch verify
  Verifying flipr_test
    * appuser .. ok
  Undeployed change:
    * users
  Verify successful

Note that the verify is successful, because all currently-deployed changes are
verified. The list of undeployed changes (just "users" here) reminds us about
the current state.

Okay, let's commit and deploy again:

  > git add .
  > git commit -am 'Add users table.'
  [master be7214a] Add users table.
   4 files changed, 31 insertions(+)
   create mode 100644 deploy/users.sql
   create mode 100644 revert/users.sql
   create mode 100644 verify/users.sql
  > sqitch deploy
  Deploying changes to flipr_test
    + users .. ok

Looks good. Check the status:

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   53c520dea482be30c426f241e74f5cbc58f3febc
  # Name:     users
  # Deployed: 2013-07-01 21:48:47 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

Excellent. Let's do some more!

=head1 Add Two at Once

Let's add a couple more changes to add functions for managing users.

  > sqitch add insert_user --requires users --requires appuser \
    -n 'Creates a function to insert a user.'
  Created deploy/insert_user.sql
  Created revert/insert_user.sql
  Created verify/insert_user.sql
  Added "insert_user [users appuser]" to sqitch.plan

  > sqitch add change_pass --requires users --requires appuser \
    -n 'Creates a function to change a user password.'
  Created deploy/change_pass.sql
  Created revert/change_pass.sql
  Created verify/change_pass.sql
  Added "change_pass [users appuser]" to sqitch.plan

Now might be a good time to have a look at the deployment plan:

  > cat sqitch.plan
  %syntax-version=1.0.0-b2
  %project=flipr
  %uri=https://github.com/theory/sqitch-mysql-intro/

  appuser 2013-07-01T13:09:31Z Marge N. O’Vera <marge@example.com> # Creates a an application user.
  users [appuser] 2013-07-01T19:38:33Z Marge N. O’Vera <marge@example.com> # Creates table to track our users.
  insert_user [users appuser] 2013-07-01T19:54:08Z Marge N. O’Vera <marge@example.com> # Creates a function to insert a user.
  change_pass [users appuser] 2013-07-01T19:54:15Z Marge N. O’Vera <marge@example.com> # Creates a function to change a user password.

Each change appears on a single line with the name of the change, a bracketed
list of dependencies, a timestamp, the name and email address of the user who
planned the change, and a note.

Let's write the code for the new changes. Here's what
F<deploy/insert_user.sql> should look like:

  -- Deploy insert_user
  -- requires: users
  -- requires: appuser

  BEGIN;

  DELIMITER //

  CREATE PROCEDURE insert_user(
      nickname VARCHAR(512),
      password VARCHAR(512)
  ) SQL SECURITY DEFINER
  BEGIN
      INSERT INTO users (nickname, password, timestamp)
      VALUES (nickname, md5(password), UTC_TIMESTAMP(6));
  END
  //

  DELIMITER ;

  GRANT EXECUTE ON PROCEDURE insert_user to flipr;

  COMMIT;

Here's what F<verify/insert_user.sql> might look like, using the Sqitch
C<checkit()> function again:

  -- Verify insert_user

  BEGIN;

  SELECT sqitch.checkit(COUNT(*), 'Procedure "insert_user" does not exist')
    FROM mysql.proc
   WHERE db = database()
     AND specific_name = 'insert_user';

  ROLLBACK;

We simply take advantage of the fact that the new procedure should be listed
in the C<mysql.proc> table and throw an exception if it does not exist.

And F<revert/insert_user.sql> should look something like this:

  -- Revert insert_user
  BEGIN;
  DROP PROCEDURE insert_user;
  COMMIT;

Now for C<change_pass>; F<deploy/change_pass.sql> might look like this:

  -- Deploy change_pass
  -- requires: users
  -- requires: appuser

  BEGIN;

  DELIMITER //

  CREATE FUNCTION change_pass(
      nickname VARCHAR(512),
      oldpass  VARCHAR(512),
      newpass  VARCHAR(512)
  ) RETURNS INTEGER SQL SECURITY DEFINER
  BEGIN
      UPDATE users
         SET password = md5(newpass)
       WHERE nickname = nickname
         AND password = md5(oldpass);
      RETURN ROW_COUNT();
  END;
  //

  DELIMITER ;

  GRANT EXECUTE ON FUNCTION change_pass to flipr;

  COMMIT;

Use C<checkit()> in F<verify/change_pass.sql> again:

  BEGIN;
  SELECT sqitch.checkit(COUNT(*), 'Procedure "change_pass" does not exist')
    FROM mysql.proc
   WHERE db = database()
     AND specific_name = 'change_pass';
  COMMIT;

And of course, its C<revert> script, F<revert/change_pass.sql>, should look
something like:

  -- Revert change_pass
  BEGIN;
  DROP FUNCTION change_pass;
  REVERT;

Try em out!

  > sqitch deploy
  Deploying changes to flipr_test
    + insert_user .. ok
    + change_pass .. ok

Do we have the functions? Of course we do, they were verified. Still, have a
look:

  > mysql -u root --execute "SELECT name FROM mysql.proc WHERE db = 'flipr_test'"
  +-------------+
  | name        |
  +-------------+
  | change_pass |
  | insert_user |
  +-------------+

And what's the status?

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   3d47365408243d95d406e9f9037105a767750f50
  # Name:     change_pass
  # Deployed: 2013-07-01 22:18:01 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

Looks good. Let's make sure revert works:

  > sqitch revert -y --to @HEAD^^
  Reverting changes to users from flipr_test
    - change_pass .. ok
    - insert_user .. ok
  > mysql -u root --execute "SELECT name FROM mysql.proc WHERE db = 'flipr_test'"

Note the use of C<@HEAD^^> to specify that the revert be to two changes prior
the last deployed change. Looks good. Let's do the commit and re-deploy dance:

  > git add .
  > git commit -m 'Add `insert_user()` and `change_pass()`.'
  [master 46b3ef4] Add `insert_user()` and `change_pass()`.
   11 files changed, 118 insertions(+), 1 deletion(-)
   create mode 100644 deploy/change_pass.sql
   create mode 100644 deploy/insert_user.sql
   create mode 100644 deploy/users.sql
   create mode 100644 revert/change_pass.sql
   create mode 100644 revert/insert_user.sql
   create mode 100644 revert/users.sql
   create mode 100644 verify/change_pass.sql
   create mode 100644 verify/insert_user.sql
   create mode 100644 verify/users.sql

  > sqitch deploy
  Deploying changes to flipr_test
    + insert_user .. ok
    + change_pass .. ok

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   3d47365408243d95d406e9f9037105a767750f50
  # Name:     change_pass
  # Deployed: 2013-07-01 22:22:55 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  # 
  Nothing to deploy (up-to-date)

  > sqitch verify
  Verifying flipr_test
    * appuser .... ok
    * users ........ ok
    * insert_user .. ok
    * change_pass .. ok
  Verify successful

Great, we're fully up-to-date!

=head1 More to Come

Sqitch is a work in progress. Better integration with version control systems
is planned to make managing idempotent reworkings even easier. Stay tuned.

=head1 Author

David E. Wheeler <david@justatheory.com>

=head1 License

Copyright (c) 2012-2013 iovation Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

=cut
